# GDB analysis

[`gdb`](https://linux.die.net/man/1/gdb) is useful for us to understand how a given binary works.

## Main function

Let's see what this program does...

```gdb
  $> gdb ./level3
  (gdb) disassemble main
  Dump of assembler code for function main:
    0x0804851a <+0>:     push   %ebp
    0x0804851b <+1>:     mov    %esp,%ebp
    0x0804851d <+3>:     and    $0xfffffff0,%esp
    0x08048520 <+6>:     call   0x80484a4 <v>
    0x08048525 <+11>:    leave  
    0x08048526 <+12>:    ret  
  End of assembler dump.
```

> This `main()` only calls a `v()` function.

## Additional functions

As shown in the `main()` function another one is called, let's disasssemble it as well.

```gdb
  $> gdb ./level3
  (gdb) disassemble v
  Dump of assembler code for function main:
    0x080484a4 <+0>:     push   %ebp
    0x080484a5 <+1>:     mov    %esp,%ebp
    0x080484a7 <+3>:     sub    $0x218,%esp
    0x080484ad <+9>:     mov    0x8049860,%eax
    0x080484b2 <+14>:    mov    %eax,0x8(%esp)
    0x080484b6 <+18>:    movl   $0x200,0x4(%esp)
    0x080484be <+26>:    lea    -0x208(%ebp),%eax
    0x080484c4 <+32>:    mov    %eax,(%esp)
    0x080484c7 <+35>:    call   0x80483a0 <fgets@plt>
    0x080484cc <+40>:    lea    -0x208(%ebp),%eax
    0x080484d2 <+46>:    mov    %eax,(%esp)
    0x080484d5 <+49>:    call   0x8048390 <printf@plt>
    0x080484da <+54>:    mov    0x804988c,%eax
    0x080484df <+59>:    cmp    $0x40,%eax
    0x080484e2 <+62>:    jne    0x8048518 <v+116>
    0x080484e4 <+64>:    mov    0x8049880,%eax
    0x080484e9 <+69>:    mov    %eax,%edx
    0x080484eb <+71>:    mov    $0x8048600,%eax
    0x080484f0 <+76>:    mov    %edx,0xc(%esp)
    0x080484f4 <+80>:    movl   $0xc,0x8(%esp)
    0x080484fc <+88>:    movl   $0x1,0x4(%esp)
    0x08048504 <+96>:    mov    %eax,(%esp)
    0x08048507 <+99>:    call   0x80483b0 <fwrite@plt>
    0x0804850c <+104>:   movl   $0x804860d,(%esp)
    0x08048513 <+111>:   call   0x80483c0 <system@plt>
    0x08048518 <+116>:   leave  
    0x08048519 <+117>:   ret 
  End of assembler dump.
```

> Here we have calls to [`fgets()`](https://linux.die.net/man/3/fgets), [`printf()`](https://man7.org/linux/man-pages/man3/printf.3.html), [`fwrite()`](https://linux.die.net/man/3/fwrite) and [`system()`](https://man7.org/linux/man-pages/man3/system.3.html).

# Data

## Strings

```gdb
  0x080484eb <+71>:    mov    $0x8048600,%eax
  
  (gdb) x/s 0x8048600
  0x8048600: "Wait what?!\n"
```

The string `Wait what?!\n` is stored at address `0x8048600`.

```gdb
  0x0804850c <+104>:   movl   $0x804860d,(%esp)
  
  (gdb) x/s 0x804860d
  0x804860d: "/bin/sh"
```

The string `/bin/sh` is stored at address `0x804860d`.

## Buffers size

```gdb
  0x080484be <+26>:    lea    -0x208(%ebp),%eax

  (gdb) p 0x208
  $1 = 520
```

There is a buffer of size **520** in `v()`.

```gdb
  0x080484b6 <+18>:    movl   $0x200,0x4(%esp)

  (gdb) p 0x200
  $1 = 512
```

This instruction represent the maximum bytes read by `fgets()` in `v()` which is **512**. Inportant to note that this is less than the size of the buffer in which we'll store the result meaning **no buffer overflow** is possible here.

## Global variables

Using `info variables` in `gdb` we can get all global/static variables present in the program.

```gdb
  (gdb) info variables
  All defined variables:

  Non-debugging symbols:
  0x080485f8  _fp_hw
  0x080485fc  _IO_stdin_used
  0x08048734  __FRAME_END__
  0x08049738  __CTOR_LIST__
  0x08049738  __init_array_end
  0x08049738  __init_array_start
  0x0804973c  __CTOR_END__
  0x08049740  __DTOR_LIST__
  0x08049744  __DTOR_END__
  0x08049748  __JCR_END__
  0x08049748  __JCR_LIST__
  0x0804974c  _DYNAMIC
  0x08049818  _GLOBAL_OFFSET_TABLE_
  0x0804983c  __data_start
  0x0804983c  data_start
  0x08049840  __dso_handle
  0x08049860  stdin@@GLIBC_2.0
  0x08049880  stdout@@GLIBC_2.0
  0x08049884  completed.6159
  0x08049888  dtor_idx.6161
  0x0804988c  m
```

> All of these variables except `m` are generated by the compiler.

A variable called `m` is located at address `0x0804988c`. This could be important since, in `v()` there is a reference to this address.

```gdb
    0x080484da <+54>:    mov    0x804988c,%eax
```

It might be useful, who knows...