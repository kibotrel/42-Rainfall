# GDB analysis

[`gdb`](https://linux.die.net/man/1/gdb) is useful for us to understand how a given binary works.

## Main function

Let's see what this program does...

```gdb
  $> gdb ./level4
  (gdb) disassemble main
  Dump of assembler code for function main:
    0x080484a7 <+0>:     push   %ebp
    0x080484a8 <+1>:     mov    %esp,%ebp
    0x080484aa <+3>:     and    $0xfffffff0,%esp
    0x080484ad <+6>:     call   0x8048457 <n>
    0x080484b2 <+11>:    leave
    0x080484b3 <+12>:    ret
  End of assembler dump.
```

> This `main()` only calls a `n()` function.

## Additional functions

As shown in the `main()` function another one is called, let's disasssemble it as well.

```gdb
  $> gdb ./level4
  (gdb) disassemble n
  Dump of assembler code for function n:
    0x08048457 <+0>:     push   %ebp
    0x08048458 <+1>:     mov    %esp,%ebp
    0x0804845a <+3>:     sub    $0x218,%esp
    0x08048460 <+9>:     mov    0x8049804,%eax
    0x08048465 <+14>:    mov    %eax,0x8(%esp)
    0x08048469 <+18>:    movl   $0x200,0x4(%esp)
    0x08048471 <+26>:    lea    -0x208(%ebp),%eax
    0x08048477 <+32>:    mov    %eax,(%esp)
    0x0804847a <+35>:    call   0x8048350 <fgets@plt>
    0x0804847f <+40>:    lea    -0x208(%ebp),%eax
    0x08048485 <+46>:    mov    %eax,(%esp)
    0x08048488 <+49>:    call   0x8048444 <p>
    0x0804848d <+54>:    mov    0x8049810,%eax
    0x08048492 <+59>:    cmp    $0x1025544,%eax
    0x08048497 <+64>:    jne    0x80484a5 <n+78>
    0x08048499 <+66>:    movl   $0x8048590,(%esp)
    0x080484a0 <+73>:    call   0x8048360 <system@plt>
    0x080484a5 <+78>:    leave
    0x080484a6 <+79>:    ret
  End of assembler dump.
```

> Here we have calls to [`fgets()`](https://linux.die.net/man/3/fgets) and [`system()`](https://man7.org/linux/man-pages/man3/system.3.html). There is also a call to a custom function `p()`.

Disassembling `p()` gives us the following...

```gdb
  $> gdb ./level4
  (gdb) disassemble p
  Dump of assembler code for function p:
    0x08048444 <+0>:     push   %ebp
    0x08048445 <+1>:     mov    %esp,%ebp
    0x08048447 <+3>:     sub    $0x18,%esp
    0x0804844a <+6>:     mov    0x8(%ebp),%eax        
    0x0804844d <+9>:     mov    %eax,(%esp)
    0x08048450 <+12>:    call   0x8048340 <printf@plt>
    0x08048455 <+17>:    leave 
  End of assembler dump.
```

> Only calls [`printf()`](https://man7.org/linux/man-pages/man3/printf.3.html) and do nothing else.

This looks similar to the previous level where we used **format string** to update some variable.

# Data

## Strings

```gdb
  0x08048499 <+66>:    movl   $0x8048590,(%esp)
  
  (gdb) x/s 0x8048590
  0x8048590: "/bin/cat /home/user/level5/.pass"
```

The string `/bin/cat /home/user/level5/.pass` is stored at address `0x8048590`. It is the intended way to get the password for next user, if fed to a `system()` call.

## Buffers size

```gdb
  0x08048471 <+26>:    lea    -0x208(%ebp),%eax

  (gdb) print 0x208
  $1 = 520
```

There is a buffer of size **520** in `n()`.

```gdb
  0x08048469 <+18>:    movl   $0x200,0x4(%esp)

  (gdb) print 0x200
  $1 = 512
```

This instruction represent the maximum bytes read by `fgets()` in `n()` which is **512**. Inportant to note that this is less than the size of the buffer in which we'll store the result meaning **no buffer overflow** is possible here.

## Global variables

Using `info variables` in `gdb` we can get all global/static variables present in the program.

```gdb
  (gdb) info variables
  All defined variables:

  Non-debugging symbols:
  0x08048588  _fp_hw
  0x0804858c  _IO_stdin_used
  0x080486f8  __FRAME_END__
  0x080496fc  __CTOR_LIST__
  0x080496fc  __init_array_end
  0x080496fc  __init_array_start
  0x08049700  __CTOR_END__
  0x08049704  __DTOR_LIST__
  0x08049708  __DTOR_END__
  0x0804970c  __JCR_END__
  0x0804970c  __JCR_LIST__
  0x08049710  _DYNAMIC
  0x080497dc  _GLOBAL_OFFSET_TABLE_
  0x080497fc  __data_start
  0x080497fc  data_start
  0x08049800  __dso_handle
  0x08049804  stdin@@GLIBC_2.0
  0x08049808  completed.6159
  0x0804980c  dtor_idx.6161
  0x08049810  m
```

> All of these variables except `m` are generated by the compiler.

A variable called `m` is located at address `0x08049810`. This could be important since, in `n()` there is a reference to this address.

```gdb
  0x0804848d <+54>:    mov    0x8049810,%eax
  0x08048492 <+59>:    cmp    $0x1025544,%eax

  (gdb) print 0x1025544
  $1 = 16930116
```

It does check if this variable is equal to **16930116**. It might be useful, who knows...